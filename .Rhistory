data_B <- data_A %>% filter(Defense_Type != "No")
print(head(data_B))
# Step 3: Define the order of Kaiju_Phylum
phylum_order <- c(
"Pseudomonadota", "Bacteroidota", "Bacillota", "Campylobacterota",
"Actinomycetota", "Myxococcota", "Verrucomicrobiota", "Thermodesulfobacteriota",
"Fusobacteriota", "Acidobacteriota", "Chloroflexota", "Gemmatimonadota",
"Candidatus_Saccharibacteria", "Planctomycetota", "Cyanobacteriota",
"Bdellovibrionota", "Nitrospirota", "Spirochaetota", "Euryarchaeota",
"Deinococcota", "Fibrobacterota", "Synergistota", "Mycoplasmatota",
"Candidatus_Thermoplasmatota", "Balneolota", "Rhodothermota", "Ignavibacteriota",
"Chlamydiota", "Chlorobiota", "Thermotogota", "Kiritimatiellota",
"Lentisphaerota", "Armatimonadota", "Aquificota", "Thermomicrobiota",
"Candidatus_Binatota", "Deferribacterota", "Candidatus_Methylomirabilota",
"Candidatus_Tectomicrobia", "Candidatus_Deferrimicrobiota", "Candidatus_Kryptoniota",
"Calditrichota", "Elusimicrobiota", "Chrysiogenota", "Candidatus_Dormiibacterota",
"Nitrospinota", "Candidatus_Cloacimonadota", "Nitrososphaerota", "Thermoproteota",
"Abditibacteriota", "Vulcanimicrobiota", "Candidatus_Fervidibacterota",
"Thermosulfidibacterota", "Candidatus_Absconditabacteria", "Candidatus_Melainabacteria",
"Atribacterota", "Candidatus_Cryosericota", "Candidatus_Omnitrophota",
"Dictyoglomota", "Thermodesulfobiota", "Candidatus_Bipolaricaulota",
"Coprothermobacterota", "Candidatus_Lokiarchaeota", "Caldisericota",
"Candidatus_Borrarchaeota", "Candidatus_Micrarchaeota", "Candidatus_Korarchaeota",
"Candidatus_Culexarchaeota", "Candidatus_Hadarchaeota", "Candidatus_Bathyarchaeota",
"Candidatus_Nanohalarchaeota"
)
# Step 4: Process table A with "All_" prefix
result_A <- data_A %>%
group_by(Sample, Kaiju_Phylum) %>%
summarise(Count = n(), .groups = "drop") %>%
pivot_wider(names_from = Sample, values_from = Count, values_fill = 0) %>%
right_join(tibble(Kaiju_Phylum = phylum_order), by = "Kaiju_Phylum") %>%
arrange(match(Kaiju_Phylum, phylum_order)) %>%
mutate(across(-Kaiju_Phylum, ~replace_na(., 0))) %>%
rename_with(~paste0("All_", .), -Kaiju_Phylum)
print(head(result_A))
# Step 5: Process table B with "Defense_" prefix
result_B <- data_B %>%
group_by(Sample, Kaiju_Phylum) %>%
summarise(Count = n(), .groups = "drop") %>%
pivot_wider(names_from = Sample, values_from = Count, values_fill = 0) %>%
right_join(tibble(Kaiju_Phylum = phylum_order), by = "Kaiju_Phylum") %>%
arrange(match(Kaiju_Phylum, phylum_order)) %>%
mutate(across(-Kaiju_Phylum, ~replace_na(., 0))) %>%
rename_with(~paste0("Defense_", .), -Kaiju_Phylum)
print(head(result_B))
# Step 6: Combine results horizontally
combined_result <- result_A %>%
left_join(result_B, by = "Kaiju_Phylum")
print(head(combined_result))
# Step 7: Read the group information
group_file <- "Results/04_Taxonomy_Diff/Tables/taxonomy_nmds_group.csv"
group_info <- read_csv(group_file)
print(head(group_info))
# Step 8: Prepare data for NMDS
nmds_data <- combined_result %>%
column_to_rownames("Kaiju_Phylum") %>%  # 将Kaiju_Phylum设为行名
t() %>%  # 转置数据，使样本成为行，Phylum成为列
as.data.frame()
print(dim(nmds_data))  # 打印维度，应该是 156 x 71
print(head(nmds_data))
# Step 9: Perform NMDS
nmds_result <- metaMDS(nmds_data, distance = "bray")
print(summary(nmds_result))
nmds_result_site <- as.data.frame(scores(nmds_result)$sites)
# Step 10: Extract NMDS coordinates
nmds_coords <- as.data.frame(scores(nmds_result_site))
nmds_coords$Sample <- rownames(nmds_coords)
print(head(nmds_coords))
# Step 11: Merge NMDS coordinates with group information
plot_data <- left_join(nmds_coords, group_info, by = "Sample")
print(head(plot_data))
# Create the NMDS plot
ggplot(plot_data, aes(x = NMDS1, y = NMDS2, color = Location, shape = Country, alpha = Season)) +
geom_point(size = 3) +
theme_minimal() +
labs(title = "NMDS Plot of Taxonomic Data",
x = "NMDS1",
y = "NMDS2") +
scale_color_brewer(palette = "Set1") +
scale_shape_manual(values = c(16, 17, 18)) +  # 16 for DK (dot), 17 for UK (triangle), 18 for SP (diamond)
scale_alpha_manual(values = c("WINTER" = 0.5, "SUMMER" = 1)) +
theme(legend.position = "right")
# Save the plot
ggsave("nmds_plot_multi_dimension.png", width = 12, height = 8, dpi = 300)
# Create the NMDS plot
p <- ggplot(plot_data, aes(x = NMDS1, y = NMDS2, color = Location, shape = Country, alpha = Season)) +
geom_point(size = 3) +
stat_ellipse(aes(group = Location), level = 0.95, type = "t", linetype = 2) +
theme_minimal() +
labs(title = "NMDS Plot of Taxonomic Data with Confidence Ellipses",
x = "NMDS1",
y = "NMDS2") +
scale_color_brewer(palette = "Set1") +
scale_shape_manual(values = c(16, 17, 18)) +  # 16 for DK (dot), 17 for UK (triangle), 18 for SP (diamond)
scale_alpha_manual(values = c("WINTER" = 0.5, "SUMMER" = 1)) +
theme(legend.position = "right")
# Add centroid labels for each Location
centroids <- plot_data %>%
group_by(Location) %>%
summarise(NMDS1 = mean(NMDS1), NMDS2 = mean(NMDS2))
p <- p + geom_text_repel(plot_data = centroids, aes(x = NMDS1, y = NMDS2, label = Location),
color = "black", fontface = "bold", box.padding = 0.5, inherit.aes = FALSE)
# Save the plot
ggsave("Results/04_Taxonomy_Diff/01_NMDS/nmds_plot_with_ellipses2.png", plot = p, width = 12, height = 8, dpi = 300)
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE)
# Load required libraries
library(dplyr)
library(tidyr)
library(readr)
library(vegan)
library(ggplot2)
library(tidyverse)
library(ggrepel)
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE)
library(circlize)
# Load required libraries
library(circlize)
# Function to create chord diagram
create_chord_diagram <- function(input_file, output_png, output_pdf) {
# Read data
dkb <- read.csv(input_file, row.names = 1)
dkb_matrix <- as.matrix(dkb)
# Set colors
color_row = c("SoF" = "#434d91", "Wad" = "#6566aa",
"PD6" = "#c6a4c5", "RM" = "#c6f0ec",
"AbiE" = "#8fced1", "AbiD" = "#53a4a6",
"Cas" = "#faaf7f", "Zor" = "#f07e40",
"CBA" = "#dc5772", "Sep" = "#ffc7c9")
color_col = c("Ps" = "#BF7EA2", "Ba" = "#BF7EA2",
"Bc" = "#BF7EA2", "Ca" = "#BF7EA2",
"Ac" = "#BF7EA2", "My" = "#BF7EA2",
"Ve" = "#BF7EA2", "Th" = "#BF7EA2",
"Ph" = "#0B2E55", "Pm" = "#9cb3ad")
state_col2 = c(color_row, color_col)
names(state_col2) = c(rownames(dkb_matrix), colnames(dkb_matrix))
# Create chord diagram
circos.clear()
# Increase margin and adjust parameters to add more space
circos.par(cell.padding = c(0.02, 0.02, 0.02, 0.02),
track.margin = c(0.01, 0.01),
start.degree = 0,
gap.degree = 5,
points.overflow.warning = FALSE)
cdm_res = chordDiagram(dkb_matrix, grid.col = state_col2,
directional = TRUE, annotationTrack = "grid",
big.gap = 10, small.gap = 1, # Slightly reduce gaps between sectors
preAllocateTracks = list(track.height = max(strwidth(unlist(dimnames(dkb_matrix))))),
link.target.prop = FALSE)
circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
sector.index = get.cell.meta.data("sector.index")
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
circos.text(mean(xlim), ylim[1] + 0.1, sector.index, # Adjust label position
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5), cex = 0.8)
}, bg.border = NA)
# Save as PNG
png(output_png, width = 1500, height = 1500, res = 150) # Increase image size
par(mar = c(20, 20, 20, 20)) # Add margin to the plot
circos.clear()
cdm_res = chordDiagram(dkb_matrix, grid.col = state_col2,
directional = TRUE, annotationTrack = "grid",
big.gap = 15, small.gap = 2, # Increase gaps between sectors
preAllocateTracks = list(track.height = 0.2),
link.target.prop = FALSE)
circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
sector.index = get.cell.meta.data("sector.index")
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
circos.text(mean(xlim), ylim[1] + 0.2, sector.index, # Move labels further out
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
dev.off()
# Save as PDF
pdf(output_pdf, width = 12, height = 12) # Increase PDF size
par(mar = c(10, 10, 10, 10)) # Add margin to the plot
circos.clear()
cdm_res = chordDiagram(dkb_matrix, grid.col = state_col2,
directional = TRUE, annotationTrack = "grid",
big.gap = 15, small.gap = 2, # Increase gaps between sectors
preAllocateTracks = list(track.height = 0.2),
link.target.prop = FALSE)
circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
sector.index = get.cell.meta.data("sector.index")
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
circos.text(mean(xlim), ylim[1] + 0.2, sector.index, # Move labels further out
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5), cex = 1.5, font = 2)
}, bg.border = NA)
dev.off()
}
# Function to process all files in a directory
process_directory <- function(input_dir, output_dir) {
# Create output directory if it doesn't exist
dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)
# Get list of CSV files in input directory
csv_files <- list.files(input_dir, pattern = "\\.csv$", full.names = TRUE)
# Process each file
for (input_file in csv_files) {
file_name <- tools::file_path_sans_ext(basename(input_file))
output_png <- file.path(output_dir, paste0(file_name, ".png"))
output_pdf <- file.path(output_dir, paste0(file_name, ".pdf"))
create_chord_diagram(input_file, output_png, output_pdf)
cat("Processed:", input_file, "\n")
cat("Output PNG:", output_png, "\n")
cat("Output PDF:", output_pdf, "\n\n")
}
}
# Set input and output directories
input_dir <- "Collect/08_Circular/Final_GCGB_top10"
output_dir <- "Results/08_Circular/GCGB_top10_new"
# Process all files in the input directory
process_directory(input_dir, output_dir)
print("All chord diagrams have been generated and saved in the output directory.")
# Load required libraries
library(circlize)
# Function to create chord diagram
create_chord_diagram <- function(input_file, output_png, output_pdf) {
# Read data
dkb <- read.csv(input_file, row.names = 1)
dkb_matrix <- as.matrix(dkb)
# Set colors
color_row = c("SoF" = "#342765", "Wad" = "#6566aa",
"PD6" = "#c6a4c5", "RM" = "#c6f0ec",
"AbiE" = "#8fced1", "AbiD" = "#53a4a6",
"Cas" = "#faaf7f", "Zor" = "#f07e40",
"CBA" = "#dc5772", "Sep" = "#ffc7c9")
color_col = c("Ps" = "#BF7EA2", "Ba" = "#BF7EA2",
"Bc" = "#BF7EA2", "Ca" = "#BF7EA2",
"Ac" = "#BF7EA2", "My" = "#BF7EA2",
"Ve" = "#BF7EA2", "Th" = "#BF7EA2",
"Ph" = "#0B2E55", "Pm" = "#9cb3ad")
state_col2 = c(color_row, color_col)
names(state_col2) = c(rownames(dkb_matrix), colnames(dkb_matrix))
# Create chord diagram
circos.clear()
# Increase margin and adjust parameters to add more space
circos.par(cell.padding = c(0.02, 0.02, 0.02, 0.02),
track.margin = c(0.01, 0.01),
start.degree = 0,
gap.degree = 5,
points.overflow.warning = FALSE)
cdm_res = chordDiagram(dkb_matrix, grid.col = state_col2,
directional = TRUE, annotationTrack = "grid",
big.gap = 10, small.gap = 1, # Slightly reduce gaps between sectors
preAllocateTracks = list(track.height = max(strwidth(unlist(dimnames(dkb_matrix))))),
link.target.prop = FALSE)
circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
sector.index = get.cell.meta.data("sector.index")
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
circos.text(mean(xlim), ylim[1] + 0.1, sector.index, # Adjust label position
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5), cex = 0.8)
}, bg.border = NA)
# Save as PNG
png(output_png, width = 1500, height = 1500, res = 150) # Increase image size
par(mar = c(20, 20, 20, 20)) # Add margin to the plot
circos.clear()
cdm_res = chordDiagram(dkb_matrix, grid.col = state_col2,
directional = TRUE, annotationTrack = "grid",
big.gap = 15, small.gap = 2, # Increase gaps between sectors
preAllocateTracks = list(track.height = 0.2),
link.target.prop = FALSE)
circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
sector.index = get.cell.meta.data("sector.index")
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
circos.text(mean(xlim), ylim[1] + 0.2, sector.index, # Move labels further out
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
dev.off()
# Save as PDF
pdf(output_pdf, width = 12, height = 12) # Increase PDF size
par(mar = c(10, 10, 10, 10)) # Add margin to the plot
circos.clear()
cdm_res = chordDiagram(dkb_matrix, grid.col = state_col2,
directional = TRUE, annotationTrack = "grid",
big.gap = 15, small.gap = 2, # Increase gaps between sectors
preAllocateTracks = list(track.height = 0.2),
link.target.prop = FALSE)
circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
sector.index = get.cell.meta.data("sector.index")
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
circos.text(mean(xlim), ylim[1] + 0.2, sector.index, # Move labels further out
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5), cex = 1.5, font = 2)
}, bg.border = NA)
dev.off()
}
# Function to process all files in a directory
process_directory <- function(input_dir, output_dir) {
# Create output directory if it doesn't exist
dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)
# Get list of CSV files in input directory
csv_files <- list.files(input_dir, pattern = "\\.csv$", full.names = TRUE)
# Process each file
for (input_file in csv_files) {
file_name <- tools::file_path_sans_ext(basename(input_file))
output_png <- file.path(output_dir, paste0(file_name, ".png"))
output_pdf <- file.path(output_dir, paste0(file_name, ".pdf"))
create_chord_diagram(input_file, output_png, output_pdf)
cat("Processed:", input_file, "\n")
cat("Output PNG:", output_png, "\n")
cat("Output PDF:", output_pdf, "\n\n")
}
}
# Set input and output directories
input_dir <- "Collect/08_Circular/Final_GCGB_top10"
output_dir <- "Results/08_Circular/GCGB_top10_new"
# Process all files in the input directory
process_directory(input_dir, output_dir)
print("All chord diagrams have been generated and saved in the output directory.")
# Load required libraries
library(circlize)
# Function to create chord diagram
create_chord_diagram <- function(input_file, output_png, output_pdf) {
# Read data
dkb <- read.csv(input_file, row.names = 1)
dkb_matrix <- as.matrix(dkb)
# Set colors
color_row = c("SoF" = "#d0cab7", "Wad" = "#6566aa",
"PD6" = "#c6a4c5", "RM" = "#c6f0ec",
"AbiE" = "#8fced1", "AbiD" = "#4d9793",
"Cas" = "#f7ded5", "Zor" = "#f07e40",
"CBA" = "#dc5772", "Sep" = "#beccc5")
color_col = c("Ps" = "#BF7EA2", "Ba" = "#BF7EA2",
"Bc" = "#BF7EA2", "Ca" = "#BF7EA2",
"Ac" = "#BF7EA2", "My" = "#BF7EA2",
"Ve" = "#BF7EA2", "Th" = "#BF7EA2",
"Ph" = "#0B2E55", "Pm" = "#9cb3ad")
state_col2 = c(color_row, color_col)
names(state_col2) = c(rownames(dkb_matrix), colnames(dkb_matrix))
# Create chord diagram
circos.clear()
# Increase margin and adjust parameters to add more space
circos.par(cell.padding = c(0.02, 0.02, 0.02, 0.02),
track.margin = c(0.01, 0.01),
start.degree = 0,
gap.degree = 5,
points.overflow.warning = FALSE)
cdm_res = chordDiagram(dkb_matrix, grid.col = state_col2,
directional = TRUE, annotationTrack = "grid",
big.gap = 10, small.gap = 1, # Slightly reduce gaps between sectors
preAllocateTracks = list(track.height = max(strwidth(unlist(dimnames(dkb_matrix))))),
link.target.prop = FALSE)
circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
sector.index = get.cell.meta.data("sector.index")
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
circos.text(mean(xlim), ylim[1] + 0.1, sector.index, # Adjust label position
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5), cex = 0.8)
}, bg.border = NA)
# Save as PNG
png(output_png, width = 1500, height = 1500, res = 150) # Increase image size
par(mar = c(20, 20, 20, 20)) # Add margin to the plot
circos.clear()
cdm_res = chordDiagram(dkb_matrix, grid.col = state_col2,
directional = TRUE, annotationTrack = "grid",
big.gap = 15, small.gap = 2, # Increase gaps between sectors
preAllocateTracks = list(track.height = 0.2),
link.target.prop = FALSE)
circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
sector.index = get.cell.meta.data("sector.index")
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
circos.text(mean(xlim), ylim[1] + 0.2, sector.index, # Move labels further out
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
dev.off()
# Save as PDF
pdf(output_pdf, width = 12, height = 12) # Increase PDF size
par(mar = c(10, 10, 10, 10)) # Add margin to the plot
circos.clear()
cdm_res = chordDiagram(dkb_matrix, grid.col = state_col2,
directional = TRUE, annotationTrack = "grid",
big.gap = 15, small.gap = 2, # Increase gaps between sectors
preAllocateTracks = list(track.height = 0.2),
link.target.prop = FALSE)
circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
sector.index = get.cell.meta.data("sector.index")
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
circos.text(mean(xlim), ylim[1] + 0.2, sector.index, # Move labels further out
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5), cex = 1.5, font = 2)
}, bg.border = NA)
dev.off()
}
# Function to process all files in a directory
process_directory <- function(input_dir, output_dir) {
# Create output directory if it doesn't exist
dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)
# Get list of CSV files in input directory
csv_files <- list.files(input_dir, pattern = "\\.csv$", full.names = TRUE)
# Process each file
for (input_file in csv_files) {
file_name <- tools::file_path_sans_ext(basename(input_file))
output_png <- file.path(output_dir, paste0(file_name, ".png"))
output_pdf <- file.path(output_dir, paste0(file_name, ".pdf"))
create_chord_diagram(input_file, output_png, output_pdf)
cat("Processed:", input_file, "\n")
cat("Output PNG:", output_png, "\n")
cat("Output PDF:", output_pdf, "\n\n")
}
}
# Set input and output directories
input_dir <- "Collect/08_Circular/Final_GCGB_top10"
output_dir <- "Results/08_Circular/GCGB_top10_new"
# Process all files in the input directory
process_directory(input_dir, output_dir)
print("All chord diagrams have been generated and saved in the output directory.")
# Load required libraries
library(circlize)
# Function to create chord diagram
create_chord_diagram <- function(input_file, output_png, output_pdf) {
# Read data
dkb <- read.csv(input_file, row.names = 1)
dkb_matrix <- as.matrix(dkb)
# Set colors
color_row = c("SoF" = "#d0cab7", "Wad" = "#6566aa",
"PD6" = "#c6a4c5", "RM" = "#c6f0ec",
"AbiE" = "#8fced1", "AbiD" = "#4d9793",
"Cas" = "#f7ded5", "Zor" = "#f07e40",
"CBA" = "#dc5772", "Sep" = "#beccc5")
color_col = c("Ps" = "#BF7EA2", "Ba" = "#BF7EA2",
"Bc" = "#BF7EA2", "Ca" = "#BF7EA2",
"Ac" = "#BF7EA2", "My" = "#BF7EA2",
"Ve" = "#BF7EA2", "Th" = "#BF7EA2",
"Ph" = "#0B2E55", "Pm" = "#9cb3ad")
state_col2 = c(color_row, color_col)
names(state_col2) = c(rownames(dkb_matrix), colnames(dkb_matrix))
# Create chord diagram
circos.clear()
# Increase margin and adjust parameters to add more space
circos.par(cell.padding = c(0.02, 0.02, 0.02, 0.02),
track.margin = c(0.01, 0.01),
start.degree = 0,
gap.degree = 5,
points.overflow.warning = FALSE)
cdm_res = chordDiagram(dkb_matrix, grid.col = state_col2,
directional = TRUE, annotationTrack = "grid",
big.gap = 10, small.gap = 1, # Slightly reduce gaps between sectors
preAllocateTracks = list(track.height = max(strwidth(unlist(dimnames(dkb_matrix))))),
link.target.prop = FALSE)
circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
sector.index = get.cell.meta.data("sector.index")
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
circos.text(mean(xlim), ylim[1] + 0.1, sector.index, # Adjust label position
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5), cex = 0.8)
}, bg.border = NA)
# Save as PNG
png(output_png, width = 1500, height = 1500, res = 150) # Increase image size
par(mar = c(20, 20, 20, 20)) # Add margin to the plot
circos.clear()
cdm_res = chordDiagram(dkb_matrix, grid.col = state_col2,
directional = TRUE, annotationTrack = "grid",
big.gap = 15, small.gap = 2, # Increase gaps between sectors
preAllocateTracks = list(track.height = 0.2),
link.target.prop = FALSE)
circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
sector.index = get.cell.meta.data("sector.index")
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
circos.text(mean(xlim), ylim[1] + 0.2, sector.index, # Move labels further out
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
dev.off()
# Save as PDF
pdf(output_pdf, width = 12, height = 12) # Increase PDF size
par(mar = c(10, 10, 10, 10)) # Add margin to the plot
circos.clear()
cdm_res = chordDiagram(dkb_matrix, grid.col = state_col2,
directional = TRUE, annotationTrack = "grid",
big.gap = 15, small.gap = 2, # Increase gaps between sectors
preAllocateTracks = list(track.height = 0.2),
link.target.prop = FALSE)
circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
sector.index = get.cell.meta.data("sector.index")
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
circos.text(mean(xlim), ylim[1] + 0.2, sector.index, # Move labels further out
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5), cex = 2.5, font = 2)
}, bg.border = NA)
dev.off()
}
# Function to process all files in a directory
process_directory <- function(input_dir, output_dir) {
# Create output directory if it doesn't exist
dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)
# Get list of CSV files in input directory
csv_files <- list.files(input_dir, pattern = "\\.csv$", full.names = TRUE)
# Process each file
for (input_file in csv_files) {
file_name <- tools::file_path_sans_ext(basename(input_file))
output_png <- file.path(output_dir, paste0(file_name, ".png"))
output_pdf <- file.path(output_dir, paste0(file_name, ".pdf"))
create_chord_diagram(input_file, output_png, output_pdf)
cat("Processed:", input_file, "\n")
cat("Output PNG:", output_png, "\n")
cat("Output PDF:", output_pdf, "\n\n")
}
}
# Set input and output directories
input_dir <- "Collect/08_Circular/Final_GCGB_top10"
output_dir <- "Results/08_Circular/GCGB_top10_new"
# Process all files in the input directory
process_directory(input_dir, output_dir)
print("All chord diagrams have been generated and saved in the output directory.")
source("~/Warehouse/GitHub/SAD/321_Co-Occ_with_nonplasmids_mges_boxplot.r", echo=TRUE)
source("~/Warehouse/GitHub/SAD/321_Co-Occ_with_nonplasmids_mges_boxplot.r", echo=TRUE)
